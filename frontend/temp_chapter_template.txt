'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import {
  ChapterTopBar,
  ChapterTaskPanel,
  ChapterDialogueBox,
  ChapterRewardScreen,
} from '@/components/chapters/shared';
import { PointBasedMinigame, GeometryPhysicsGame } from '@/components/chapters/minigames';
import { ConceptCard, LessonGrid, VisualDemo } from '@/components/chapters/lessons';
import ChapterProgressModal from '@/components/chapters/ChapterProgressModal';
import { useChapterData, useChapterDialogue, useChapterAudio } from '@/hooks/chapters';
import {
  CHAPTER1_CASTLE_ID,
  CHAPTER1_NUMBER,
  CHAPTER1_OPENING_DIALOGUE,
  CHAPTER1_LESSON_DIALOGUE,
  CHAPTER1_MINIGAME_DIALOGUE,
  CHAPTER1_MINIGAME_LEVELS,
  CHAPTER1_LEARNING_OBJECTIVES,
  CHAPTER1_XP_VALUES,
  CHAPTER1_CONCEPTS,
} from '@/constants/chapters/castle1/chapter1';
import Image from 'next/image';
import { awardLessonXP, completeChapter } from '@/api/chapters';
import { submitQuizAttempt, getUserQuizAttempts } from '@/api/chapterQuizzes';
import { submitMinigameAttempt } from '@/api/minigames';
import { useChapterStore } from '@/store/chapterStore';
import baseStyles from '@/styles/chapters/chapter-base.module.css';
import minigameStyles from '@/styles/chapters/minigame-shared.module.css';
import lessonStyles from '@/styles/chapters/lesson-shared.module.css';

type SceneType = 'opening' | 'lesson' | 'minigame' | 'quiz1' | 'quiz2' | 'quiz3' | 'reward';

const CHAPTER_KEY = 'castle1-chapter1';

export default function Chapter1Page() {
  const router = useRouter();
  
  // Zustand store
  const chapterStore = useChapterStore();
  const savedProgress = chapterStore.getChapterProgress(CHAPTER_KEY);
  
  // Progress modal state
  const [showProgressModal, setShowProgressModal] = useState(false);
  const [hasCheckedProgress, setHasCheckedProgress] = useState(false);
  
  // Initialize chapter in store if not exists and check for existing progress
  useEffect(() => {
    // Get existing progress BEFORE initializing (to check if it's truly new)
    const existingProgress = chapterStore.getChapterProgress(CHAPTER_KEY);
    const hasRealProgress = existingProgress && (
      existingProgress.currentScene !== 'opening' ||
      Object.keys(existingProgress.completedTasks || {}).length > 0 ||
      existingProgress.earnedXP.lesson > 0 ||
      existingProgress.earnedXP.minigame > 0 ||
      existingProgress.earnedXP.quiz > 0
    );
    
    chapterStore.initializeChapter(CHAPTER_KEY);
    
    // Check if user has disabled this modal for this chapter
    const dontShowAgain = localStorage.getItem(`${CHAPTER_KEY}-dont-show-modal`);
    const modalExpiration = localStorage.getItem(`${CHAPTER_KEY}-modal-expiration`);
    
    // Check if the "don't show again" has expired
    let shouldShowModal = true;
    if (dontShowAgain === 'true' && modalExpiration) {
      const expirationTime = parseInt(modalExpiration, 10);
      if (Date.now() < expirationTime) {
        // Still within the 5-minute window, don't show modal
        shouldShowModal = false;
      } else {
        // Expired, clear the flags
        localStorage.removeItem(`${CHAPTER_KEY}-dont-show-modal`);
        localStorage.removeItem(`${CHAPTER_KEY}-modal-expiration`);
      }
    }
    
    // Only show modal if there's REAL progress (not just initialization)
    if (!hasCheckedProgress && hasRealProgress && shouldShowModal) {
      setShowProgressModal(true);
      setHasCheckedProgress(true);
    } else {
      setHasCheckedProgress(true);
    }
  }, []);
  
  // Scene and state management - initialize from store or defaults
  const [currentScene, setCurrentScene] = useState<SceneType>(
    (savedProgress?.currentScene as SceneType) || 'opening'
  );
  const [isMuted, setIsMuted] = useState(savedProgress?.isMuted || false);
  const [autoAdvanceEnabled, setAutoAdvanceEnabled] = useState(savedProgress?.autoAdvanceEnabled || false);
  const [currentMinigameLevel, setCurrentMinigameLevel] = useState(savedProgress?.currentMinigameLevel || 0);
  
  // Track which lesson tasks have been checked to prevent duplicates (using semantic keys)
  const checkedLessonTasksRef = React.useRef<Set<string>>(new Set());
  const previousMessageIndexRef = React.useRef<number>(-1);
  
  // Task tracking - initialize from store or defaults
  const [completedTasks, setCompletedTasks] = useState<Record<string, boolean>>(
    savedProgress?.completedTasks || {}
  );
  const [failedTasks, setFailedTasks] = useState<Record<string, boolean>>(
    savedProgress?.failedTasks || {}
  );
  
  // Quiz state - initialize from store or defaults
  const [quizAnswers, setQuizAnswers] = useState<Record<string, string>>(
    savedProgress?.quizAnswers || {}
  );
  const [quizAttempts, setQuizAttempts] = useState(savedProgress?.quizAttempts || 0);
  const [quizFeedback, setQuizFeedback] = useState<'correct' | 'incorrect' | null>(null);
  
  // XP tracking - initialize from store or defaults
  const [earnedXP, setEarnedXP] = useState({
    lesson: savedProgress?.earnedXP.lesson || 0,
    minigame: savedProgress?.earnedXP.minigame || 0,
    quiz: savedProgress?.earnedXP.quiz || 0,
  });

  // Quiz score tracking
  const [quizScore, setQuizScore] = useState<number | null>(null);

  // Custom hooks
  const { chapterId, quiz, minigame, loading, error, authLoading, userProfile } = useChapterData({
    castleId: CHAPTER1_CASTLE_ID,
    chapterNumber: CHAPTER1_NUMBER,
  });

  const {
    displayedText,
    isTyping,
    messageIndex,
    handleDialogueClick,
    handleNextMessage,
    resetDialogue,
  } = useChapterDialogue({
    dialogue: currentScene === 'opening' ? CHAPTER1_OPENING_DIALOGUE : 
             currentScene === 'lesson' ? CHAPTER1_LESSON_DIALOGUE.map(d => d.text) : 
             CHAPTER1_MINIGAME_DIALOGUE,
    autoAdvance: autoAdvanceEnabled,
    autoAdvanceDelay: 3000,
    typingSpeed: 30,
    onDialogueComplete: handleDialogueComplete,
  });

  const { playNarration, stopAudio } = useChapterAudio({ isMuted });

  // Sync state changes to store
  useEffect(() => {
    chapterStore.setScene(CHAPTER_KEY, currentScene);
  }, [currentScene]);

  useEffect(() => {
    chapterStore.setMinigameLevel(CHAPTER_KEY, currentMinigameLevel);
  }, [currentMinigameLevel]);

  useEffect(() => {
    chapterStore.setAudioSettings(CHAPTER_KEY, isMuted, autoAdvanceEnabled);
  }, [isMuted, autoAdvanceEnabled]);

  // Sync completed tasks to store
  useEffect(() => {
    Object.entries(completedTasks).forEach(([taskId, completed]) => {
      if (completed) {
        const savedProgress = chapterStore.getChapterProgress(CHAPTER_KEY);
        if (!savedProgress?.completedTasks[taskId]) {
          chapterStore.setTaskComplete(CHAPTER_KEY, taskId);
        }
      }
    });
  }, [completedTasks]);

  // Sync failed tasks to store
  useEffect(() => {
    Object.entries(failedTasks).forEach(([taskId, failed]) => {
      if (failed) {
        const savedProgress = chapterStore.getChapterProgress(CHAPTER_KEY);
        if (!savedProgress?.failedTasks[taskId]) {
          chapterStore.setTaskFailed(CHAPTER_KEY, taskId);
        }
      }
    });
  }, [failedTasks]);

  // Sync quiz answers to store
  useEffect(() => {
    Object.entries(quizAnswers).forEach(([questionId, answer]) => {
      const savedProgress = chapterStore.getChapterProgress(CHAPTER_KEY);
      if (savedProgress?.quizAnswers[questionId] !== answer) {
        chapterStore.setQuizAnswer(CHAPTER_KEY, questionId, answer);
      }
    });
  }, [quizAnswers]);

  // Sync earned XP to store
  useEffect(() => {
    if (earnedXP.lesson > 0) {
      chapterStore.setEarnedXP(CHAPTER_KEY, 'lesson', earnedXP.lesson);
    }
    if (earnedXP.minigame > 0) {
      chapterStore.setEarnedXP(CHAPTER_KEY, 'minigame', earnedXP.minigame);
    }
    if (earnedXP.quiz > 0) {
      chapterStore.setEarnedXP(CHAPTER_KEY, 'quiz', earnedXP.quiz);
    }
  }, [earnedXP]);

  // Fetch quiz score when entering reward scene
  useEffect(() => {
    const fetchQuizScore = async () => {
      if (currentScene === 'reward' && quiz?.id) {
        try {
          // Add a small delay to ensure the backend has finished processing
          await new Promise(resolve => setTimeout(resolve, 500));
          
          const attempts = await getUserQuizAttempts(quiz.id);
          console.log('[Chapter1] Fetched quiz attempts:', attempts);
          
          if (attempts && attempts.length > 0) {
            // Get the most recent attempt (assuming attempts are ordered by creation date)
            const sortedAttempts = attempts.sort((a: any, b: any) => {
              return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
            });
            const mostRecentScore = sortedAttempts[0]?.score || 0;
            console.log('[Chapter1] Most recent quiz score:', mostRecentScore);
            setQuizScore(mostRecentScore);
          }
        } catch (error) {
          console.error('Failed to fetch quiz score:', error);
          // Fallback to calculating score from earnedXP
          setQuizScore(null);
        }
      }
    };
    
    fetchQuizScore();
  }, [currentScene, quiz?.id]);

  // Track lesson progress and mark tasks as dialogue progresses
  React.useEffect(() => {
    if (currentScene === 'lesson' && messageIndex >= 0 && messageIndex < CHAPTER1_LESSON_DIALOGUE.length) {
      const currentDialogue = CHAPTER1_LESSON_DIALOGUE[messageIndex];
      
      // Skip if already processed this dialogue
      if (checkedLessonTasksRef.current.has(currentDialogue.key)) {
